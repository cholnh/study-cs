
기술 인터뷰 예상 질문---------------------------------------------------------

	[ 프로젝트 ]
		- 서류에 낸 프로젝트 여기에 정리
	
		- 원래의 목적에 맞게 기술을 사용하고 있는가?
		
		- 내가 해낸 것에 대해서 보다 풍부하게 말할 준비를 하자.
		
		- 대체할 수 있는 다른 기술들

	[ 공통/자바 ]
		- String, StringBuffer, StringBuilder 차이
			String은 불변객체이다. -> 새로운 값을 append 할 때 마다 새로운 객체가 생성 -> 가비지 증가로 인한 힙메모리 부족 -> GC빈도 증가 (메모리, 성능 비효율)
			가변성을 갖는 StringBuilder 도입. 동일 객체내에서 문자열 변경 가능. 그러나 Thread-UnSafe.
			StringBuffer 도입. Thread-Safe 하다는 것은 멀티 스레딩 환경에서 안전하다는 것. 
			(Thread-Safe: 변수 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램 실행에 문제가 없음을 뜻함.
			+ Thread-Safe하기 위해서 는 재진입성(Re-entrancy)을 띄어야 한다, 각 스레드의 호출마다 정확한 결과가 리턴되어야함,
			+ 공유 자원을 접근할 때 하나의 스레드만 접근하며 write과정은 atomic 해야 함.)
			
			
		- 불변객체/가변객체

		- 자바 메모리구조 (heap, perm)

		- Volatile
			변수를 Main Memory에 저장하겠다는 것을 명시함.
			매번 변수를 읽을 때마다 CPU Cache에 저장된 값이 아닌 Main Memory 에서 읽음. (멀티스레딩으로 인한 변수 값 불일치 문제 때문)
			스레드들은 멀티 스레딩 환경에서 제각각 사용하는 CPU Cache 영역이 다름, 캐시 내 값(변수 값)이 제각각 다르게 됨.
			주의) 여러 스레드가 write 하는 것에 원자성(atomic)을 보장하기 위해서는 synchronized 또는 명시적락(Reentrant lock) 사용.
			
		- serialize (직렬화)
			JVM 메모리(힙 또는 스택)내 객체를 외부에서 사용할 수 있도록 byte 형태 데이터 변환.
			(Serializable 구현)객체 -> (ByteArrayOutputStream -> ObjectOutputStream) ObjectOutputStream을 열어서 직렬화 -> 바이트 배열
			serialVersionUID 이 동일해야 역/직렬화 가능, 또한 구조가 변하면 InvalidClassException 발생
			(주로 서블릿세션(메모리위에선 필요없지만 세션 클러스터링, OAuth 정보 db저장 등에 필요), 캐시 등)
			(메모리기반 Cache 저장용량 한계 -> Json 직렬화(경량화))
			
		- transient
			자바 직렬화중 제외하고 싶은 멤버변수를 명시하는 키워드.

		- 추상 클래스

		- 인터페이스

		- OSI 7 layer

		- RESTful API
		
		- JVM / GC
		
		- class loader
		
		- Collection
		
		- Annotation
		
		- Generic
		
		- final
		
		- 오버로딩 vs 오버라이딩
		
		- Access Modifier (접근 지정자)
		
		- Wrapper class / First Collection Class

		
	[ 디자인패턴 ]
		- SOLID
		
		- 함수형 프로그래밍
		
		- 팩토리 메서드 패턴
		
		- 싱글턴 패턴
		
		- 전략 패턴
		
		- 손상방지 패턴
		
		- 계층화 패턴
		
		- 클라-서버 패턴
		
		- 마스터-슬레이브 패턴
		
		- 파이트-필터 패턴
		
		- 브로커 패턴
		
		- 피어 투 피어 패턴
		
		- MVC 패턴
		
		- 블랙보드 패턴
		
		- 인터프리터 패턴
		
		- Publish-Subscribe 패턴
		
		
	[ 설계 ]


	[ DB/JPA ]
		- NoSQL ?

		- 데이터베이스 리플리케이션

		- 데이터베이스 파티셔닝

		- ACID
		
		- Statement vs PreparedStatement
		
		- Transaction

		- 정규화
		
		- Index
		
		- 데이터베이스 성능
		
		- jpa 는 어떻게 트랜잭션을 관리할까
		
		
	[ 서버 ]


	[ 스프링 ]
		- 제어 반전 (Inversion of control)
		
		- 의존 관계 역전 원칙 (from SOLID)
		
		- 의존성 주입 (Dependency Injection)
		
		- AOP

		
	[ 캐시 ]


	[ 네트워크 ]
		- HTTP/1.0
		
		- HTTP/1.1
		
		- HTTP/2
		
		- HTTPS
		
		- Cookie / Session
		
		- GET / POST / PUT / PATCH / DELETE
		
		- TCP VS UDP
		
		- TCP 3-way-handshake
		
		- DNS round robin
		
		- 웹 통신 흐름


	[ OS ]
		- 스레드와 프로세서 차이

		- Swapping

		- 컨텍스트 스위칭

		- 페이징 (메모리 관리 전략) / 세그먼테이션

		- 가상 메모리
		
		- Thread-safe

		- 프로세스 동기화
		
		- DeadLock

		- Race Condition
		
		- 스케줄러
		
		- 캐시 지역성
		

	[ 알고리즘 ]


	[ 자료구조 ]
		- 해시 테이블 설명
			key에 해당하는 value를 저장하는 데이터 구조.
			hash function을 통해 key에 대한 hash 값을 구하고 buckets 의 인덱스로 사용한다.
			hash function을 한 번만 수행하기 때문에 속도가 매우 빠름.
			
			충돌 처리 알고리즘
			hash function으로 index를 구할 때 중복 index가 생성되는 것을 충돌이라 한다.
			- Separate Chaining 방식 해결 (JDK 내부에서 사용중)
			index 끝부분이 -> Linked List (참조)
			충돌시, List 맨 뒤에 추가 (List 선형검색)
			cf) jdk 1.8 의 경우 노드 8개 이하 : List 사용, 8개 이상 Tree 사용 (select 성능을 높임)
			- Open Addressing 방식 해결
			해시 테이블(buckets) 빈 공간을 활용하는 방식
			그 중 Linear Probing 방식은 선형으로 다음 노드들이 비어있는지 계속 검사.
			cf) 삭제 처리가 어려움, 삭제가 일어날때, 삭제한 후에 연결 역할을 하는 Dummy node를 삽입함, 점점 쌓이다 보면 성능저하 발생,
			
			Resizing
			버킷의 사이즈가 작으면 Open Addressing 방식이든, Separate Chaining 방식이든 검색 성능이 저하 됨.
			리사이징을 통해 새로운 버킷을 생성해야 성능 향상.
			
		- 자바 HashMap (자바는 Amortized Constant Time을 위해 어떻게 해시 충돌 가능성을 줄이는가?) (Amortized Constant Time은 )
			자바 컬렉션 프레임워크 Map 인터페이스의 구현체.
			키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 중가하는 associate array(=Map<K,V>) 이다.
			cf) 키 집합인 정의역과, 값 집합인 공역의 대응에 해시 함수를 이용.
			
			Integer, Boolean 같은 객체는 값 자체를 해시함수 대상으로 사용할 수 있음.
			String, POJO에 대하여는 완전한 해시함수 제작이 사실상 불가능.
			(논리적으로 생성가능 객체수가 2^32 보다 많을 수 있음. 2^32 배열을 해시맵이 가지고 있어야 함 = 불가능)
			객체의 해시코드 나머지값을 해시 버킷 인덱스 값으로 사용한다. (정수 범위보다 작은 M, 그 크기의 배열을 해시버킷으로 사용)
			( int index = x.hashCode() % M )
			
			static int hashCode(String key) {
				int hash = 0;
				char[] ch = key.toCharArray();
				for (int i = 0; i < key.length(); i++) {
					hash = hash * 31 + ch[i];
				}
				return hash;
			}
		
		- 바이너리 트리
		
		- BST (Binary Search Tree)
		
		- Graph
		

	[ 빌드 도구 ]
		- gradle vs maven 차이

		
	[ OOP ]


	[ TDD ]
		- 유닛테스트 / 통합테스트

		- 전체 테스트 과정

		- JUnit / Mockito / Spock

		- Mock 이란


	[ DDD ]
		- 도메인 / 애그리거트


	[ MSA ]
		- 모놀리식 아키텍처

		- 마이크로서비스 아키텍처

		- 이벤트 드리븐 아키텍처

		- 도커

		- 쿠버네티스


	[ 보안 ]
		- XSS

		- CSRF

		- SQL Injection


	[ CI/CD ]


	[ SCM ]



인성 인터뷰 예상 질문---------------------------------------------------------

	- 구성원과의 갈등 해결, 협업 시 문제가 생기면

	- 나의 장/단점

	- 지원이유

	- 미래 나의 모습

	- 내가 생각하기에 좋은 회사란

	- 열정적으로 코딩을 한 적이 있나

	- 주로 활용하는 툴은

	- 지난 프로젝트의 성과 설명, 기억에 남는 업무

	- 프로젝트 진행 시 의사 결정 기준

	- 요즘 관심있는 (기술)분야

	- 매일매일 하는 공부

	- 트레픽 과부하가 생기면
		1. 어디서 발생하는지 분석
			모니터링 툴을 사용하여 병목구간 판별, 해당 시점에 생긴 로그 수집하여 분석.
		2. 무엇 때문에 발생하는지 분석
			오류, 로직(복잡도 계산) 분석으로 문제 원인을 찾음.
		3. 분석에 대한 해결방안을 고민
			문제 해결에 대한 방안을 고민.
			원인 관련 문서 찾아봄,
			사수, 지인 등 관련 종사자에게 관련 경험에 대한 피드백,
			인터넷 자문,
			여러 해결방안을 리스트업 한 후 장/단점을 나열하여 정렬,
			베스트 케이스를 선택.
		4. 해결방안의 사이드 이펙트 고려
			테스트 케이스가 필요한지 구상 후 테스트코드 작성 후 구현, 리펙토링 진행.		
		5. 로컬에서 과부하 테스트 후 배포

	- 최악의 버그
	
	- 5년후 나의 모습
	

손코딩 예상 문제---------------------------------------------------------

	- 재귀 피보나치 / 팩토리얼
	- 메모이제이션 피보나치 / 팩토리얼
	- 각종 정렬 (삽입, 선택, 버블, 힙, 퀵, 합병 등)
	- 각종 자료구조 (스택, 큐, 해시테이블, 연결리스트 등)
	- 문자열 (아나그램 판별, 문자열안에 문자들 고유문자인지 판별(아스키/유니코드))
	- 최소공배수/최대공약수
	- 문자열 조작(뒤집기, 조합하기, 잘라내기 등등), 간단한 길찾기, Stack 응용, Queue 응용, LinkedList 응용, Binary Search, 깊이우선탐색, 너비우선탐색, 기초 확률 문제 
	- https://github.com/JaeYeopHan/algorithm_basic_java

면접 마지막에
	" 면접을 볼 때, 가장 무서운 것이 있습니다.
		면접에서 탈락되는 것 보다, 제가 잘못된 지식을 갖고 잘못된 지식이 옳다고 믿으며 무지하게 사는게 더 두려운데요.
		결례가 안된다면 제가 면접동안 잘못된 지식을 갖고 있었거나 조금은 더 좋은 개발태도가 있었다면 간단하게 피드백 부탁드립니다. "
